// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Artist {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  albums    Album[]
  tracks    Track[]

  @@map("artists")
}

model Album {
  id          String   @id @default(cuid())
  title       String
  artistId    String
  albumType   AlbumType @default(PLAYLIST)
  youtubeId   String?   @unique
  coverUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  artist      Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)
  tracks      Track[]

  @@map("albums")
}

model Track {
  id          String   @id @default(cuid())
  title       String
  artistId    String
  albumId     String
  duration    Int      @default(0)
  filePath    String   @unique
  fileSize    Int      @default(0)
  youtubeId   String?  @unique
  likeability Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  artist      Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)
  album       Album    @relation(fields: [albumId], references: [id], onDelete: Cascade)
  
  // Analytics relations
  listeningSessions ListeningSession[]
  trackRatings      TrackRating[]
  playbackSegments  PlaybackSegment[]

  @@map("tracks")
}

model MissingTrack {
  id        String            @id @default(cuid())
  artist    String
  title     String
  youtubeId String?           @unique
  album     String?           @default("Unknown Album")
  status    MissingTrackStatus @default(PENDING)
  reason    String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  @@unique([artist, title, album])
  @@index([status])
  @@map("missing_tracks")
}

// User analytics models
model ListeningSession {
  id          String   @id @default(cuid())
  trackId     String
  userId      String   @default("default") // For now, single user system
  startTime   DateTime @default(now())
  endTime     DateTime?
  totalTime   Int      @default(0) // Total seconds listened
  completed   Boolean  @default(false) // Did user listen to completion
  skipped     Boolean  @default(false) // Did user skip the track
  createdAt   DateTime @default(now())

  track       Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  segments    PlaybackSegment[]

  @@map("listening_sessions")
}

model TrackRating {
  id        String   @id @default(cuid())
  trackId   String
  userId    String   @default("default") // For now, single user system
  rating    Int      @default(0) // Positive/negative points from +/- buttons
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([trackId, userId])
  @@map("track_ratings")
}

model PlaybackSegment {
  id                String   @id @default(cuid())
  trackId           String
  sessionId         String
  startPosition     Int      // Start position in seconds
  endPosition       Int      // End position in seconds
  duration          Int      // Duration of this segment in seconds
  createdAt         DateTime @default(now())

  track             Track            @relation(fields: [trackId], references: [id], onDelete: Cascade)
  listeningSession  ListeningSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("playback_segments")
}

enum AlbumType {
  ALBUM
  PLAYLIST
  SINGLE
}

enum MissingTrackStatus {
  PENDING
  DOWNLOADED
  MANUAL
  IGNORED
}
